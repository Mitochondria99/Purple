For the following questions, youâ€™ll look at the [SafeTransferLib](https://github.com/Vectorized/solady/blob/efd63173997c6e30a2e45cd889cdd3968598a4c2/src/utils/SafeTransferLib.sol) from the Solady repo.

Weâ€™ll go over the `balanceOf` function together to get an initial understanding, the following questions pertain to the `safeTransferFrom`, `safeTransfer`, and `safeApprove` functions.




## 1. In the safeTransferFrom function, what does `0x23b872dd000000000000000000000000` represent and what does it mean when used in the following context on line 192: `mstore(0x0c, 0x23b872dd000000000000000000000000)`.

Ans.

`0x23b872dd000000000000000000000000` represents the function signature of the transferFrom(address from, address to, uint256 value) function which is generated by taking the keccak256 hash of the function's prototype and then taking the first 4 bytes of the resulting hash.
 `mstore` implies,"Store the following data in memory at the given location".
`0x0c` is the memory location where we want to store data and `0x23b872dd000000000000000000000000` is the data we're storing.
 It's like saying "transfer funds from one account to another" at location` 0x0c`




## 2. In the `safeTransferFrom` function, why is `shl` used on line 191 to shift the `from` to the left by 96 bits?

Ans.

When encoding for the Ethereum Virtual Machine (EVM), the layout of function selectors and the arguments in memory would be:

First 4 bytes: Function selector (`0x23b872dd`)

Next 32 bytes: `from` address

Next 32 bytes: `to` address

Last 32 bytes: amount or value

addresses are only 20 bytes long. When stored in a 32-byte word, the address takes up the last 20 bytes of the word, with the first 12 bytes (or 96 bits) being zeros.
So, when `` mstore(0x2c, shl(96, from))// Store the `from` argument `` is executed, it's placing the `from `address into the latter part of the 32-byte word. `The shl(96, from)` is shifting the `20-byte` from address to the left by `96 bits`, so when it's stored in memory, it will occupy the last 20 bytes of that 32-byte segment, aligning it correctly for the function call.



## 3. In the `safeTransferFrom` function, is this memory safe assembly? Why or why not?

   Yes,this is memory safe assembly.
   function starts with `let m := mload(0x40)` which fetches the current **free memory pointer** which indicates where in memory we can safely start writing data without overwriting anything important.
   At the end of the function, with mstore(0x40, m), it resets the memory pointer back to its original position, ensuring that subsequent operations won't accidentally overwrite the memory we've just used.

 function stores its variables at specific memory locations (0x60, 0x40, 0x2c, etc.). By doing so, it's avoiding any accidental overwrites. There's actually a clear detail of where each piece of data is stored.
   In my opinion, the function checks the outcome of the call. If the call isn't successful, the function reverts the transaction with an error, ensuring that failures are handled without any unpredictable outcomes.



##  4. In the `safeTransferFrom` function, on line 197, why is 0x1c provided as the 4th argument to `call`?

   In the safeTransferFrom function,  call function is used to invoke another contract which is of format:

```]
call(gaslimit, to, value, in_offset, in_size, out_offset, out_size)

```

gaslimit: maximum amount of gas provided for the call.

to: address of the contract being called.

value:  amount of ether (in wei) sent with the call.

in_offset:  starting position in memory where the input data is located.

in_size: size (in bytes) of the input data.

out_offset: starting position in memory where the output data will be stored.

out_size:  size (in bytes) of the space allocated for the output data.

```

    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)
```

0x1c is provided as the in_offset which means that the input data for this call starts from memory location 0x1c.





## 5. In the `safeTransfer` function, on line 266, why is `revert` used with `0x1c` and `0x04`.

   The revert function is used to stop and revert the current call, essentially canceling all state changes made during the call.
   
   `revert(start_position, size)`

   start_position: This is the memory location where the revert reason/data begins.
   
   size: This is the size(bytes) of the revert reason/data.

   `revert(0x1c, 0x04)`

   0x1c: starting memory location of the revert reason/data.
   
   0x04: length of the revert reason/data is 4 bytes.

   so if transfer fails, the function stops and reverts any state changes, sending back an error message or code that's 4 bytes long and starts from memory location 0x1c.




## 6. In the `safeTransfer` function, on line 268, why is `0` mstoreâ€™d at `0x34`.

 memory location 0x34 was used temporarily to store a value (amount). Before exiting the function, the code resets that memory spot by setting it to 0, a way of cleaning up after using the memory to avoid errors.



## 7. In the `safeApprove` function, on line 317, why is `mload(0x00)` validated for equality to 1?

   `  or(eq(mload(0x00), 1), iszero(returndatasize()))`

   `eq(mload(0x00), 1)` checks if the value at memory location 0x00 is equal to 1

   `` mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256 ``

   This line is storing the function signature for approve(address,uint256) in memory at location 0x00.

   Now after function call which invokes the approve function on the provided token, if the token's approve function was implemented such that it returns boolean, then this boolean value would be what is stored at memory location 0x00 after the call.

   Therefore, eq(mload(0x00), 1) checks if the approve call returned true



## 8. In the `safeApprove` function, if the `token` returns `false` from the `approve(address,uint256)` function, what happens?

In short if the approve function returns false, the safeApprove function will trigger a revert with an error code. 


   1. approve function will return false,represented by 0.
   2. memory location 0x00 will then hold this value (0).
   3. condition eq(mload(0x00), 1) == false
   4. approve function returns nothing, then iszero(returndatasize()) would be == true. However, since the function did return false,
      this condition == false as well.
      Given that both conditions in the or statement are false, the entire or statement ==false.
   6. ` and` statement would then also == false
   7.  outermost if iszero(...) would == true
   8. code inside the if block will execute. It will store the error code for ApproveFailed() in memory location 0x00 and then invoke the revert function with arguments 0x1c and 0x04 to halt execution and revert all state changes ðŸ¤¯

